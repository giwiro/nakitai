```
                    $$\       $$\   $$\               $$\ 
                    $$ |      \__|  $$ |              \__|           ,/|         _.--''^``-...___.._.,;
$$$$$$$\   $$$$$$\  $$ |  $$\ $$\ $$$$$$\    $$$$$$\  $$\           /, \'.     _-'          ,--,,,--'''
$$  __$$\  \____$$\ $$ | $$  |$$ |\_$$  _|   \____$$\ $$ |         { \    `_-''       '    /}
$$ |  $$ | $$$$$$$ |$$$$$$  / $$ |  $$ |     $$$$$$$ |$$ |          `;;'            ;   ; ;
$$ |  $$ |$$  __$$ |$$  _$$<  $$ |  $$ |$$\ $$  __$$ |$$ |      ._.--''     ._,,, _..'  .;.'
$$ |  $$ |\$$$$$$$ |$$ | \$$\ $$ |  \$$$$  |\$$$$$$$ |$$ |       (,_....----'''     (,..--''
\__|  \__| \_______|\__|  \__|\__|   \____/  \_______|\__|
```

## Nakitai
[![made-with-Rust](https://img.shields.io/badge/Made%20with-Rust-orange.svg)](http://commonmark.org)
[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](https://opensource.org/licenses/MIT)

Rust multithread ransomware that encrypts each file with chacha20poly1305 which, besides
from stream (online) encrypting the files by chunks, it's also nonce-reuse
misuse-resistant (as stated in this [paper](https://eprint.iacr.org/2015/189.pdf)) and verify the chunk integrity (
authentication) with poly1350.

## What's inside ?

This project compiles 2 binaries:

1. `ransomware`: Program that will perform the encryption of the files.

2. `rescue`: GUI Program that will decrypt all the encrypted files.

![recover](assets/recover.png?raw=true)

## Folder structure

    /nakitai
    ├── README.md
    ├── .editorconfig
    ├── Cargo.toml
    ├── Cargo.lock
    ├── og_private.pem                      # Generated by `generate_rsa_keys.js`, will be used by `extract_decryption_key_nky.js` internally.
    ├── og_public.pem                       # Generated by `generate_rsa_keys.js`, will be embedded into the ransomware binary.
    ├── /assets                             # Assets used in README.md
    ├── /scripts                            # Helpful scripts in python3
    │   ├── generate_rsa_keys.js            # Generates RSA 2048 keypair: og_public.pem (this will be embedded) ad og_private.pem
    │   └── extract_decryption_key_nky.js   # Decrypts the nky key and outputs the private key.
    └── /src                                # Source code of main project
        ├── /assets                         # Assets used in the binaries (images)
        ├── /utils                          # 
        │   ├── crypto.rs                   # 
        │   ├── traverse.rs                 # 
        │   └── mod.rs                      # 
        ├── lib.rs                          # 
        └── /bin                            # 
            ├── ransomware.rs               # 
            └── recover.rs                  #

## Process (encryption model)


## Compile
  1. Before all, you will need to have OpenSSL installed.

  In the case of __Windows__ I suggest using the one provided by *Shining Light Productions*: https://slproweb.com/products/Win32OpenSSL.html

  Make sure you download the `Win32 OpenSSL v3.0.3` version (not the light), and
  don't forget to add the folder `C:\Program Files (x86)\OpenSSL-Win32\bin` to the
  `PATH` env variable and set `OPENSSL_CONF` variable to `C:\Program Files (x86)\OpenSSL-Win32\bin\openssl.cfg`.

  2. Then, you need to generate the `og_private.pem` and `og_public.pem`, for that
  you will need to execute the generation script on the root project:

  ```shell
  $ ./script/generate_rsa_keys.js
  ```

or

  ```shell
  $ node script/generate_rsa_keys.js
  ```

  3. In order to compile the code for development purposes just execute:

  ```shell
  $ cargo build
  ```

  The above will generate the `ransomware` binary, but it won't be harmful since it won't delete the
  files after encrypted and will stdout all the process.

  If you want to build for "production" then execute:

  ```shell
  $ cargo build --release --features harmful
  ```

## FAQ

* **Which AES block cipher mode should I use ?**

  There are many of them: ECB, CBC, OFB, CFB, CTR, XTS.
  Since we are going to encrypt more than one block ECB is off the table.
  CBC, OFB and CFB are quite similar, they use the output of each block to
  feed the key of the next block (in ECB blocks are independent), so it can be
  any of this 3. Maybe we can consider CTR, since it's benefit is with
  parallelism and encryption is cpu intensive. ([Source Stackoverflow](https://stackoverflow.com/a/1220869/3412989))


* **How should I generate random bytes (for iv, nonce or key) ?**
  
  We need to guarantee the randomness of the generation of bytes, so using a weak seed
  such as the system clock (which is used by default) can be very predictable. That's why
  we need [PRNG](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) 
  (Pseudo Random Number Generation).

  
## Legal Disclaimer

```
The author does not hold any responsibility for the bad use of this tool,
remember that attacking targets without prior consent is illegal and punished by law.
```
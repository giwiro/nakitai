```
                    $$\       $$\   $$\               $$\ 
                    $$ |      \__|  $$ |              \__|           ,/|         _.--''^``-...___.._.,;
$$$$$$$\   $$$$$$\  $$ |  $$\ $$\ $$$$$$\    $$$$$$\  $$\           /, \'.     _-'          ,--,,,--'''
$$  __$$\  \____$$\ $$ | $$  |$$ |\_$$  _|   \____$$\ $$ |         { \    `_-''       '    /}
$$ |  $$ | $$$$$$$ |$$$$$$  / $$ |  $$ |     $$$$$$$ |$$ |          `;;'            ;   ; ;
$$ |  $$ |$$  __$$ |$$  _$$<  $$ |  $$ |$$\ $$  __$$ |$$ |      ._.--''     ._,,, _..'  .;.'
$$ |  $$ |\$$$$$$$ |$$ | \$$\ $$ |  \$$$$  |\$$$$$$$ |$$ |       (,_....----'''     (,..--''
\__|  \__| \_______|\__|  \__|\__|   \____/  \_______|\__|
```

## Nakitai
[![made-with-Rust](https://img.shields.io/badge/Made%20with-Rust-orange.svg)](http://commonmark.org)
[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](https://opensource.org/licenses/MIT)

Rust multithread ransomware that stream encrypts each file with chacha20poly1305 which, besides
from stream (online) encrypting the files by chunks, it's also nonce-reuse
misuse-resistant (as stated in this [paper](https://eprint.iacr.org/2015/189.pdf)) and verify the chunk integrity 
(authentication) with poly1350.

## What's inside ?

This project compiles 2 binaries:

1. `ransomware`: Program that will perform the encryption of the files.

2. `rescue`: GUI Program that will decrypt all the encrypted files.

![recover](assets/recover.png?raw=true)

## Folder structure

    /nakitai
    ├── README.md
    ├── .editorconfig
    ├── Cargo.toml
    ├── Cargo.lock
    ├── og_private.pem                      # Generated by `generate_rsa_keys.js`, will be used by `extract_decrypt_key_nky.js` internally.
    ├── og_public.pem                       # Generated by `generate_rsa_keys.js`, will be embedded into the ransomware binary.
    ├── /assets                             # Assets used in README.md
    ├── /scripts                            # Helpful scripts in python3
    │   ├── generate_rsa_keys.js            # Generates RSA 2048 keypair: og_public.pem (this will be embedded) ad og_private.pem
    │   └── extract_decrypt_key_nky.js   # Decrypts the nky key and outputs the private key.
    └── /src                                # Source code of main project
        ├── /assets                         # Assets used in the binaries (images)
        ├── /utils                          # 
        │   ├── crypto.rs                   # 
        │   ├── traverse.rs                 # 
        │   └── mod.rs                      # 
        ├── lib.rs                          # 
        └── /bin                            # 
            ├── ransomware.rs               # 
            └── recover.rs                  #

## Process (encryption model)
  1. RSA og keypair generated (by js script).

![recover](assets/generate_og_keys.png?raw=true)

  2. Before the binaries are compiled, first `lib.rs` gets compiled and included in
  each binary. The `og_public.pem` key will be embedded in the `ransomware` bin.

![recover](assets/compile.png?raw=true)

  3. Once the ransomware gets executed, it will perform then `decrypt_key.nky` in 4 steps:

     1. Generate another RSA 2048 keypair: `private.pem` and `public.pem`.
     2. Symmetric encrypt the `private.pem`. For that a `key` and a `iv` will be generated 
        securely using a PRNG function. Then it will take the `key`, `iv` and the `message`,
        apply an AES-256-CBC block cipher encryption and will product the `private_key_ciphertext`.
     3. Asymmetric encrypt the previously created `key`. Using the embedded `og_public.pem`
        will RSA encrypt the `key` and produce the `key_ciphertext`.
     4. Finally, we join all the encrypted parts with a fixed (hardcoded) safeword ("H4k" <=> `[0x48, 0x34, 0x6B]`)
        and will encode all these bytes using base64 algorithm and generate the `decrypt_key.nky`.

![recover](assets/generate_nky_key.png?raw=true)

  4. After that, the ransomware will traverse all "interesting" files and will encrypt them in 2
     steps:

     1. First it wil generate a file encryption `key` and a `nonce` using a PRNG function and then asymmetric encrypt the
        `key` with the `public.pem` generated previously. This will produce a `key_ciphertext` (this key ciphertext is from
        the key generated to encrypt a single file). Once the `key_ciphertext` is generated, then it will be written in the
        destination file (`dest_file.nakitai`) along the `nonce` and the fixed safeword ("H4k").
     2. Finally, the "interesting" file will be opened and encrypted using the `key` and `nonce` generated previously. This
        will produce a `ciphertext` in a stream way, that means that every chunk encrypted (that will have the same size as
        plaintext + some bytes for integrity check) will be appended to the `dest_file.nakitai`. Doing it this way (by chunks)
        won't load all the file in RAM at once, this is particular helpful when we have really large files and limited RAM.

![recover](assets/encrypt_file.png?raw=true)

## Compile
  1. Before all, you will need to have OpenSSL installed.

  In the case of __Windows__ I suggest using the one provided by *Shining Light Productions*: https://slproweb.com/products/Win32OpenSSL.html

  Make sure you download the `Win32 OpenSSL v3.0.3` version (not the light), and
  don't forget to add the folder `C:\Program Files (x86)\OpenSSL-Win32\bin` to the
  `PATH` env variable and set `OPENSSL_CONF` variable to `C:\Program Files (x86)\OpenSSL-Win32\bin\openssl.cfg`.

  2. Then, you need to generate the `og_private.pem` and `og_public.pem`, for that
  you will need to execute the generation script on the root project:

  ```shell
  $ ./script/generate_rsa_keys.js
  ```

or

  ```shell
  $ node script/generate_rsa_keys.js
  ```

  3. In order to compile the code for development purposes just execute:

  ```shell
  $ cargo build
  ```

  The above will generate the `ransomware` binary, but it won't be harmful since it won't delete the
  files after encrypted and will stdout all the process.

  If you want to build for "production" then execute:

  ```shell
  $ cargo build --release --features harmful
  ```

## FAQ

* **What are `iv` and `nonce` and what are its differences ?**

  


* **Which AES block cipher mode should I use ?**

  There are many of them: ECB, CBC, OFB, CFB, CTR, XTS.
  Since we are going to encrypt more than one block ECB is off the table.
  CBC, OFB and CFB are quite similar, they use the output of each block to
  feed the key of the next block (in ECB blocks are independent), so it can be
  any of this 3. Maybe we can consider CTR, since it's benefit is with
  parallelism and encryption is cpu intensive. ([Source Stackoverflow](https://stackoverflow.com/a/1220869/3412989))


* **How should I generate random bytes (for iv, nonce or key) ?**
  
  We need to guarantee the randomness of the generation of bytes, so using a weak seed
  such as the system clock (which is used by default) can be very predictable. That's why
  we need [PRNG](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) 
  (Pseudo Random Number Generation).

  
## Legal Disclaimer

```
The author does not hold any responsibility for the bad use of this tool,
remember that attacking targets without prior consent is illegal and punished by law.
```